{"version":3,"sources":["../src/engine.ts","../src/utils.ts","../src/operator/all.ts","../src/operator/and.ts","../src/operator/any.ts","../src/operator/eq.ts","../src/operator/gt.ts","../src/operator/gte.ts","../src/operator/in.ts","../src/operator/lt.ts","../src/operator/lte.ts","../src/operator/ne.ts","../src/operator/none.ts","../src/operator/not.ts","../src/operator/notIn.ts","../src/operator/or.ts","../src/serializer.ts"],"sourcesContent":["import type { OperatorInterace } from \"./operator/operator_interace.js\";\n\n/**\n * The core engine for evaluating decision rules.\n *\n * The Engine class provides the main interface for executing rules\n * against a given context. It acts as an orchestrator that delegates\n * the actual computation to the individual rule operators.\n *\n * @example\n * ```typescript\n * import { Engine } from './engine.js';\n * import { eq } from './operator/eq.js';\n *\n * const engine = new Engine();\n * const rule = eq('user.age', 25);\n * const context = { user: { age: 25 } };\n *\n * const result = engine.evaluate(rule, context);\n * console.log(result); // true\n * ```\n */\nexport class Engine {\n  /**\n   * Evaluates a rule against the provided context.\n   *\n   * This method takes a rule (which implements the OperatorInterface)\n   * and executes it against the given context object. The context\n   * provides the data that the rule will be evaluated against.\n   *\n   * @param rule - The rule to evaluate, must implement OperatorInterface\n   * @param context - The data context to evaluate the rule against (defaults to empty object)\n   * @returns True if the rule passes, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const engine = new Engine();\n   * const rule = and(\n   *   eq('user.age', 25),\n   *   eq('user.status', 'active')\n   * );\n   * const context = {\n   *   user: { age: 25, status: 'active' }\n   * };\n   *\n   * const result = engine.evaluate(rule, context);\n   * console.log(result); // true\n   * ```\n   */\n  evaluate(rule: OperatorInterace, context: object = {}): boolean {\n    return rule.compute(context);\n  }\n}\n","/**\n * Retrieves a value from a nested object using a dot-notation path.\n *\n * This utility function allows you to access deeply nested properties\n * in an object using a string path like \"user.profile.name\". It safely\n * handles cases where intermediate properties are null or undefined.\n *\n * @param obj - The object to traverse\n * @param path - The dot-notation path to the desired property (e.g., \"user.profile.name\")\n * @returns The value at the specified path, or undefined if the path doesn't exist\n *\n * @example\n * ```typescript\n * const data = {\n *   user: {\n *     profile: {\n *       name: \"John Doe\",\n *       age: 30\n *     },\n *     settings: {\n *       theme: \"dark\"\n *     }\n *   }\n * };\n *\n * getValueFromPath(data, \"user.profile.name\"); // \"John Doe\"\n * getValueFromPath(data, \"user.profile.age\");  // 30\n * getValueFromPath(data, \"user.nonexistent\");  // undefined\n * getValueFromPath(data, \"user.profile.address.street\"); // undefined\n * ```\n *\n * @example Array access\n * ```typescript\n * const data = {\n *   users: [\n *     { name: \"Alice\", id: 1 },\n *     { name: \"Bob\", id: 2 }\n *   ]\n * };\n *\n * getValueFromPath(data, \"users.0.name\"); // \"Alice\"\n * getValueFromPath(data, \"users.1.id\");   // 2\n * getValueFromPath(data, \"users.5.name\"); // undefined\n * ```\n */\nexport function getValueFromPath(obj: unknown, path: string): unknown {\n  // Check if path contains wildcard\n  if (path.includes(\"*\")) {\n    return getValueFromPathWithWildcard(obj, path);\n  }\n\n  return path.split(\".\").reduce((acc, part) => {\n    if (acc === null || acc === undefined) {\n      return undefined;\n    }\n    if (typeof acc === \"object\" && acc !== null && part in acc) {\n      return (acc as Record<string, unknown>)[part];\n    }\n    return undefined;\n  }, obj);\n}\n\n/**\n * Handles path resolution with wildcard (*) support for array traversal.\n *\n * When a wildcard (*) is encountered in the path, it treats the current value\n * as an array and applies the remaining path to each element, returning an\n * array of results.\n *\n * @param obj - The object to traverse\n * @param path - The dot-notation path with potential wildcards\n * @returns The resolved value(s) - can be a single value or array of values\n *\n * @example\n * ```typescript\n * const data = {\n *   users: [\n *     { name: \"Alice\", roles: [\"admin\", \"user\"] },\n *     { name: \"Bob\", roles: [\"user\"] }\n *   ]\n * };\n *\n * getValueFromPath(data, \"users.*.name\");     // [\"Alice\", \"Bob\"]\n * getValueFromPath(data, \"users.*.roles.0\");  // [\"admin\", \"user\"]\n * ```\n */\nfunction getValueFromPathWithWildcard(obj: unknown, path: string): unknown {\n  const parts = path.split(\".\");\n  let current = obj;\n\n  for (let i = 0; i < parts.length; i++) {\n    const part = parts[i];\n\n    if (current === null || current === undefined) {\n      return undefined;\n    }\n\n    if (part === \"*\") {\n      // Wildcard encountered - current must be an array\n      if (!Array.isArray(current)) {\n        return undefined;\n      }\n\n      // Get remaining path after the wildcard\n      const remainingPath = parts.slice(i + 1).join(\".\");\n\n      if (remainingPath === \"\") {\n        // No more path after wildcard, return the array itself\n        return current;\n      }\n\n      // Apply remaining path to each array element\n      const results = current.map((item) => {\n        if (remainingPath.includes(\"*\")) {\n          // Nested wildcard - recursive call\n          return getValueFromPathWithWildcard(item, remainingPath);\n        } else {\n          // Simple path - use regular resolution\n          return getValueFromPath(item, remainingPath);\n        }\n      });\n\n      // Flatten nested arrays from recursive wildcard calls\n      return results.some(Array.isArray)\n        ? results.flat()\n        : results.filter((item) => item !== undefined);\n    } else {\n      // Regular path part\n      if (typeof current === \"object\" && current !== null && part in current) {\n        current = (current as Record<string, unknown>)[part];\n      } else {\n        return undefined;\n      }\n    }\n  }\n\n  return current;\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace } from \"./operator_interace.js\";\n\n/**\n * Creates an ALL operator that checks if all elements in an array match a condition.\n *\n * This function creates a rule that evaluates to true if ALL elements in the specified\n * array satisfy the provided condition. It's useful for ensuring that every element\n * in an array meets certain criteria.\n *\n * @param arrayPath - Path to the array in the context (e.g., \"user.roles\")\n * @param condition - The condition to test against each array element\n * @returns An ALL operator instance\n *\n * @example Basic usage with object properties\n * ```typescript\n * const rule = all('user.roles', eq('active', true));\n * const context = {\n *   user: {\n *     roles: [\n *       { name: 'user', active: true },\n *       { name: 'admin', active: true }\n *     ]\n *   }\n * };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example With complex nested conditions\n * ```typescript\n * const rule = all('user.permissions',\n *   and(\n *     ne('status', 'revoked'),\n *     gt('expiresAt', Date.now())\n *   )\n * );\n * ```\n *\n * @example Ensuring all orders are completed\n * ```typescript\n * const rule = all('user.orders', eq('status', 'completed'));\n * ```\n */\nexport function all(\n  arrayPath: string,\n  condition: OperatorInterace\n): OperatorInterace {\n  return new All(arrayPath, condition);\n}\n\n/**\n * ALL operator that checks if all elements in an array match a condition.\n *\n * The All class implements array traversal with condition matching, returning true\n * only if ALL elements in the target array satisfy the specified condition. It uses\n * short-circuit evaluation, returning false as soon as any element fails the condition.\n *\n * @example\n * ```typescript\n * const allOp = new All('user.scores', gt('value', 80));\n * const context = {\n *   user: {\n *     scores: [\n *       { value: 85 },\n *       { value: 92 },\n *       { value: 88 }\n *     ]\n *   }\n * };\n * const result = allOp.compute(context); // true (all scores > 80)\n * ```\n */\nexport class All implements OperatorInterace {\n  /**\n   * Creates a new ALL operator instance.\n   *\n   * @param arrayPath - Path to the array in the context\n   * @param condition - The condition to test against each array element\n   */\n  constructor(\n    private arrayPath: string,\n    private condition: OperatorInterace\n  ) {}\n\n  /**\n   * Evaluates the ALL operation on the specified array.\n   *\n   * This method resolves the array path, then tests each element against\n   * the provided condition. Returns false as soon as any element fails\n   * the condition (short-circuit evaluation).\n   *\n   * @param context - Context object containing the array to evaluate\n   * @returns True if ALL elements match the condition, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const allOp = new All('products', gte('price', 10));\n   * const context = {\n   *   products: [\n   *     { price: 15 },\n   *     { price: 20 },\n   *     { price: 12 }\n   *   ]\n   * };\n   * const result = allOp.compute(context); // true (all prices >= 10)\n   * ```\n   */\n  compute(context?: object): boolean {\n    if (!context) {\n      return false;\n    }\n\n    const arrayValue = getValueFromPath(context, this.arrayPath);\n\n    // If path doesn't resolve to an array, return false\n    if (!Array.isArray(arrayValue)) {\n      return false;\n    }\n\n    // Empty arrays return true (all elements of empty set satisfy any condition)\n    if (arrayValue.length === 0) {\n      return true;\n    }\n\n    // Test each element against the condition\n    for (const element of arrayValue) {\n      // Evaluate condition with element as root context\n      try {\n        if (!this.condition.compute(element)) {\n          return false; // Short-circuit: one element failed\n        }\n      } catch {\n        // If condition evaluation fails for this element, consider it as false\n        return false;\n      }\n    }\n\n    return true; // All elements passed the condition\n  }\n\n  /**\n   * Converts the ALL operator to its JSON representation.\n   *\n   * This method serializes the operator, array path, and condition to a JSON format\n   * that can be stored, transmitted, or reconstructed later.\n   *\n   * @returns A JSON object representing the ALL operator\n   *\n   * @example\n   * ```typescript\n   * const allOp = new All('user.permissions', eq('granted', true));\n   * const json = allOp.toJSON();\n   * // Result: {\n   * //   operator: \"all\",\n   * //   args: [\n   * //     \"user.permissions\",\n   * //     { operator: \"eq\", args: [\"granted\", true] }\n   * //   ]\n   * // }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"all\",\n      args: [this.arrayPath, this.condition.toJSON()],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\n/**\n * Creates a logical AND operator that evaluates multiple conditions.\n *\n * This function creates a rule that returns true only when ALL of the\n * provided conditions evaluate to true. If any condition is false,\n * the entire AND operation returns false.\n *\n * @param args - Variable number of operands (literals, context paths, or nested operators)\n * @returns An AND operator instance\n *\n * @example Basic AND operation\n * ```typescript\n * const rule = and(\n *   eq('user.age', 25),\n *   eq('user.status', 'active')\n * );\n * const context = { user: { age: 25, status: 'active' } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example Complex nested AND\n * ```typescript\n * const rule = and(\n *   gt('user.age', 18),\n *   or(\n *     eq('user.role', 'admin'),\n *     eq('user.role', 'moderator')\n *   ),\n *   eq('user.active', true)\n * );\n * ```\n */\nexport function and(...args: Array<OperatorValue>): OperatorInterace {\n  return new And(...args);\n}\n\n/**\n * Logical AND operator that evaluates multiple conditions.\n *\n * The And class implements logical conjunction, requiring ALL operands\n * to evaluate to true for the overall result to be true. It uses\n * short-circuit evaluation, stopping at the first false condition.\n *\n * @example\n * ```typescript\n * const andOp = new And(\n *   eq('user.age', 25),\n *   eq('user.active', true)\n * );\n * const context = { user: { age: 25, active: true } };\n * const result = andOp.compute(context); // true\n * ```\n */\nexport class And implements OperatorInterace {\n  private args: Array<OperatorValue>;\n\n  /**\n   * Creates a new AND operator instance.\n   *\n   * @param args - Variable number of operands to evaluate with AND logic\n   */\n  constructor(...args: Array<OperatorValue>) {\n    this.args = args;\n  }\n\n  /**\n   * Evaluates the AND operation across all operands.\n   *\n   * This method uses short-circuit evaluation, returning false as soon as\n   * any operand evaluates to false. All operands must be truthy for the\n   * result to be true. It handles context path resolution and nested operators.\n   *\n   * @param context - Optional context object for resolving path-based operands\n   * @returns True if ALL operands evaluate to true, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const andOp = new And(\n   *   eq('user.age', 25),\n   *   gt('user.score', 80),\n   *   eq('user.verified', true)\n   * );\n   * const context = {\n   *   user: { age: 25, score: 85, verified: true }\n   * };\n   * const result = andOp.compute(context); // true\n   * ```\n   */\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    return this.args.every((arg) => {\n      return resolveValue(arg);\n    });\n  }\n\n  /**\n   * Converts the AND operator to its JSON representation.\n   *\n   * This method serializes the operator and all its operands to a JSON format,\n   * recursively handling nested operators while preserving the logical structure.\n   *\n   * @returns A JSON object representing the AND operator and its operands\n   *\n   * @example\n   * ```typescript\n   * const andOp = new And(\n   *   eq('user.age', 25),\n   *   eq('user.status', 'active')\n   * );\n   * const json = andOp.toJSON();\n   * // Result: {\n   * //   operator: \"and\",\n   * //   args: [\n   * //     { operator: \"eq\", args: [\"user.age\", 25] },\n   * //     { operator: \"eq\", args: [\"user.status\", \"active\"] }\n   * //   ]\n   * // }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"and\",\n      args: this.args.map((arg) => {\n        return typeof arg === \"object\" && arg !== null && \"toJSON\" in arg\n          ? arg.toJSON()\n          : arg;\n      }),\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace } from \"./operator_interace.js\";\n\n/**\n * Creates an ANY operator that checks if at least one element in an array matches a condition.\n *\n * This function creates a rule that evaluates to true if ANY element in the specified\n * array satisfies the provided condition. It's useful for checking array membership\n * with complex conditions.\n *\n * @param arrayPath - Path to the array in the context (e.g., \"user.roles\")\n * @param condition - The condition to test against each array element\n * @returns An ANY operator instance\n *\n * @example Basic usage with object properties\n * ```typescript\n * const rule = any('user.roles', eq('name', 'admin'));\n * const context = {\n *   user: {\n *     roles: [\n *       { name: 'user', active: true },\n *       { name: 'admin', active: true }\n *     ]\n *   }\n * };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example With complex nested conditions\n * ```typescript\n * const rule = any('user.permissions',\n *   and(\n *     eq('resource', 'posts'),\n *     eq('action', 'write')\n *   )\n * );\n * ```\n *\n * @example With wildcard path\n * ```typescript\n * const rule = any('user.roles.*.permissions', eq('admin'));\n * ```\n */\nexport function any(\n  arrayPath: string,\n  condition: OperatorInterace\n): OperatorInterace {\n  return new Any(arrayPath, condition);\n}\n\n/**\n * ANY operator that checks if at least one element in an array matches a condition.\n *\n * The Any class implements array traversal with condition matching, returning true\n * if ANY element in the target array satisfies the specified condition. It provides\n * a powerful way to query arrays with complex logic.\n *\n * @example\n * ```typescript\n * const anyOp = new Any('user.orders', gt('amount', 100));\n * const context = {\n *   user: {\n *     orders: [\n *       { amount: 50 },\n *       { amount: 150 },\n *       { amount: 75 }\n *     ]\n *   }\n * };\n * const result = anyOp.compute(context); // true (150 > 100)\n * ```\n */\nexport class Any implements OperatorInterace {\n  /**\n   * Creates a new ANY operator instance.\n   *\n   * @param arrayPath - Path to the array in the context\n   * @param condition - The condition to test against each array element\n   */\n  constructor(\n    private arrayPath: string,\n    private condition: OperatorInterace\n  ) {}\n\n  /**\n   * Evaluates the ANY operation on the specified array.\n   *\n   * This method resolves the array path, then tests each element against\n   * the provided condition. Returns true as soon as any element matches\n   * (short-circuit evaluation).\n   *\n   * @param context - Context object containing the array to evaluate\n   * @returns True if ANY element matches the condition, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const anyOp = new Any('products', eq('category', 'electronics'));\n   * const context = {\n   *   products: [\n   *     { category: 'books' },\n   *     { category: 'electronics' },\n   *     { category: 'clothing' }\n   *   ]\n   * };\n   * const result = anyOp.compute(context); // true\n   * ```\n   */\n  compute(context?: object): boolean {\n    if (!context) {\n      return false;\n    }\n\n    const arrayValue = getValueFromPath(context, this.arrayPath);\n\n    // If path doesn't resolve to an array, return false\n    if (!Array.isArray(arrayValue)) {\n      return false;\n    }\n\n    // Test each element against the condition\n    for (const element of arrayValue) {\n      // Evaluate condition with element as root context\n      try {\n        if (this.condition.compute(element)) {\n          return true;\n        }\n      } catch {}\n    }\n\n    return false;\n  }\n\n  /**\n   * Converts the ANY operator to its JSON representation.\n   *\n   * This method serializes the operator, array path, and condition to a JSON format\n   * that can be stored, transmitted, or reconstructed later.\n   *\n   * @returns A JSON object representing the ANY operator\n   *\n   * @example\n   * ```typescript\n   * const anyOp = new Any('user.roles', eq('name', 'admin'));\n   * const json = anyOp.toJSON();\n   * // Result: {\n   * //   operator: \"any\",\n   * //   args: [\n   * //     \"user.roles\",\n   * //     { operator: \"eq\", args: [\"name\", \"admin\"] }\n   * //   ]\n   * // }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"any\",\n      args: [this.arrayPath, this.condition.toJSON()],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\n/**\n * Creates an equality comparison operator.\n *\n * This function creates a rule that checks if two values are equal.\n * It supports comparing literals, context paths, and nested operators.\n *\n * @param left - The left operand (can be a literal value, context path, or nested operator)\n * @param right - The right operand (can be a literal value, context path, or nested operator)\n * @returns An equality operator instance\n *\n * @example Comparing literals\n * ```typescript\n * const rule = eq(5, 5);\n * const result = engine.evaluate(rule); // true\n * ```\n *\n * @example Comparing context values\n * ```typescript\n * const rule = eq('user.age', 25);\n * const context = { user: { age: 25 } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example Comparing two context paths\n * ```typescript\n * const rule = eq('user.age', 'user.minAge');\n * const context = { user: { age: 25, minAge: 25 } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n */\nexport function eq(\n  left: OperatorValue,\n  right: OperatorValue\n): OperatorInterace {\n  return new Eq(left, right);\n}\n\n/**\n * Equality operator that compares two values for strict equality.\n *\n * The Eq class implements the equality comparison logic, supporting\n * various types of operands including literals, context paths, and\n * nested operators. It uses strict equality (===) for comparisons.\n *\n * @example\n * ```typescript\n * const eqOp = new Eq('user.status', 'active');\n * const context = { user: { status: 'active' } };\n * const result = eqOp.compute(context); // true\n * ```\n */\nexport class Eq implements OperatorInterace {\n  /**\n   * Creates a new equality operator instance.\n   *\n   * @param left - The left operand for comparison\n   * @param right - The right operand for comparison\n   */\n  constructor(\n    private left: OperatorValue,\n    private right: OperatorValue\n  ) {}\n\n  /**\n   * Evaluates the equality comparison between the two operands.\n   *\n   * This method resolves both operands (handling context paths and nested operators)\n   * and then performs a strict equality comparison between the resolved values.\n   *\n   * @param context - Optional context object for resolving path-based operands\n   * @returns True if the operands are strictly equal, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const eqOp = new Eq('user.age', 25);\n   * const context = { user: { age: 25 } };\n   * const result = eqOp.compute(context); // true\n   * ```\n   */\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const leftResult = resolveValue(this.left);\n    const rightResult = resolveValue(this.right);\n\n    return leftResult === rightResult;\n  }\n\n  /**\n   * Converts the equality operator to its JSON representation.\n   *\n   * This method serializes the operator and its operands to a JSON format\n   * that can be stored, transmitted, or reconstructed later.\n   *\n   * @returns A JSON object representing the equality operator\n   *\n   * @example\n   * ```typescript\n   * const eqOp = new Eq('user.age', 25);\n   * const json = eqOp.toJSON();\n   * // Result: { operator: \"eq\", args: [\"user.age\", 25] }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"eq\",\n      args: [\n        typeof this.left === \"object\" &&\n        this.left !== null &&\n        \"toJSON\" in this.left\n          ? this.left.toJSON()\n          : this.left,\n        typeof this.right === \"object\" &&\n        this.right !== null &&\n        \"toJSON\" in this.right\n          ? this.right.toJSON()\n          : this.right,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\n/**\n * Creates a greater than comparison operator.\n *\n * This function creates a rule that checks if the left operand is\n * greater than the right operand. Both operands are evaluated and\n * compared using the > operator.\n *\n * @param left - The left operand (can be a literal value, context path, or nested operator)\n * @param right - The right operand (can be a literal value, context path, or nested operator)\n * @returns A greater than operator instance\n *\n * @example Comparing literals\n * ```typescript\n * const rule = gt(10, 5);\n * const result = engine.evaluate(rule); // true\n * ```\n *\n * @example Comparing context values\n * ```typescript\n * const rule = gt('user.age', 18);\n * const context = { user: { age: 25 } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example Comparing two context paths\n * ```typescript\n * const rule = gt('user.score', 'user.minScore');\n * const context = { user: { score: 85, minScore: 60 } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n */\nexport function gt(\n  left: OperatorValue,\n  right: OperatorValue\n): OperatorInterace {\n  return new Gt(left, right);\n}\n\n/**\n * Greater than operator that compares two numeric values.\n *\n * The Gt class implements the greater than comparison logic, supporting\n * various types of operands including numbers, context paths, and\n * nested operators. It performs numeric comparison using the > operator.\n *\n * @example\n * ```typescript\n * const gtOp = new Gt('user.age', 21);\n * const context = { user: { age: 25 } };\n * const result = gtOp.compute(context); // true\n * ```\n */\nexport class Gt implements OperatorInterace {\n  /**\n   * Creates a new greater than operator instance.\n   *\n   * @param left - The left operand for comparison\n   * @param right - The right operand for comparison\n   */\n  constructor(\n    private left: OperatorValue,\n    private right: OperatorValue\n  ) {}\n\n  /**\n   * Evaluates the greater than comparison between the two operands.\n   *\n   * This method resolves both operands (handling context paths and nested operators)\n   * and then performs a greater than comparison between the resolved values.\n   *\n   * @param context - Optional context object for resolving path-based operands\n   * @returns True if the left operand is greater than the right operand, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const gtOp = new Gt('user.score', 80);\n   * const context = { user: { score: 95 } };\n   * const result = gtOp.compute(context); // true\n   * ```\n   */\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const leftResult = resolveValue(this.left);\n    const rightResult = resolveValue(this.right);\n\n    // Type guard for comparison - both operands must be numbers or strings\n    if (\n      (typeof leftResult === \"number\" || typeof leftResult === \"string\") &&\n      (typeof rightResult === \"number\" || typeof rightResult === \"string\")\n    ) {\n      return leftResult > rightResult;\n    }\n\n    return false;\n  }\n\n  /**\n   * Converts the greater than operator to its JSON representation.\n   *\n   * This method serializes the operator and its operands to a JSON format\n   * that can be stored, transmitted, or reconstructed later.\n   *\n   * @returns A JSON object representing the greater than operator\n   *\n   * @example\n   * ```typescript\n   * const gtOp = new Gt('user.age', 18);\n   * const json = gtOp.toJSON();\n   * // Result: { operator: \"gt\", args: [\"user.age\", 18] }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"gt\",\n      args: [\n        typeof this.left === \"object\" &&\n        this.left !== null &&\n        \"toJSON\" in this.left\n          ? this.left.toJSON()\n          : this.left,\n        typeof this.right === \"object\" &&\n        this.right !== null &&\n        \"toJSON\" in this.right\n          ? this.right.toJSON()\n          : this.right,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\nexport function gte(\n  left: OperatorValue,\n  right: OperatorValue\n): OperatorInterace {\n  return new Gte(left, right);\n}\n\nexport class Gte implements OperatorInterace {\n  constructor(\n    private left: OperatorValue,\n    private right: OperatorValue\n  ) {}\n\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const leftResult = resolveValue(this.left);\n    const rightResult = resolveValue(this.right);\n\n    // Type guard for comparison - both operands must be numbers or strings\n    if (\n      (typeof leftResult === \"number\" || typeof leftResult === \"string\") &&\n      (typeof rightResult === \"number\" || typeof rightResult === \"string\")\n    ) {\n      return leftResult >= rightResult;\n    }\n\n    return false;\n  }\n\n  toJSON(): RuleJson {\n    return {\n      operator: \"gte\",\n      args: [\n        typeof this.left === \"object\" &&\n        this.left !== null &&\n        \"toJSON\" in this.left\n          ? this.left.toJSON()\n          : this.left,\n        typeof this.right === \"object\" &&\n        this.right !== null &&\n        \"toJSON\" in this.right\n          ? this.right.toJSON()\n          : this.right,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\n/**\n * Creates an IN operator that checks if a value exists in a list.\n *\n * This function creates a rule that checks if the given value is\n * present in the provided array. It supports checking literals,\n * context paths, and values from nested operators.\n *\n * @param value - The value to search for (can be a literal, context path, or nested operator)\n * @param list - The array to search within\n * @returns An IN operator instance\n *\n * @example Checking literal value\n * ```typescript\n * const rule = In('admin', ['admin', 'moderator', 'user']);\n * const result = engine.evaluate(rule); // true\n * ```\n *\n * @example Checking context value\n * ```typescript\n * const rule = In('user.role', ['admin', 'moderator']);\n * const context = { user: { role: 'admin' } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example Checking with numbers\n * ```typescript\n * const rule = In('user.score', [85, 90, 95, 100]);\n * const context = { user: { score: 90 } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n */\nexport function In(\n  value: OperatorValue,\n  list: Array<unknown>\n): OperatorInterace {\n  return new InOperator(value, list);\n}\n\n/**\n * IN operator that checks if a value exists within an array.\n *\n * The InOperator class implements membership testing, checking whether\n * a resolved value is present in the provided array. It supports\n * various types of values and uses strict equality for comparisons.\n *\n * @example\n * ```typescript\n * const inOp = new InOperator('user.department', ['engineering', 'design', 'product']);\n * const context = { user: { department: 'engineering' } };\n * const result = inOp.compute(context); // true\n * ```\n */\nexport class InOperator implements OperatorInterace {\n  /**\n   * Creates a new IN operator instance.\n   *\n   * @param value - The value to search for in the list\n   * @param list - The array to search within\n   */\n  constructor(\n    private value: OperatorValue,\n    private list: Array<unknown>\n  ) {}\n\n  /**\n   * Evaluates whether the value exists in the provided list.\n   *\n   * This method resolves the value (handling context paths and nested operators)\n   * and then checks if it exists in the array using strict equality comparison.\n   *\n   * @param context - Optional context object for resolving path-based values\n   * @returns True if the value is found in the list, false otherwise\n   *\n   * @example\n   * ```typescript\n   * const inOp = new InOperator('user.status', ['active', 'pending', 'verified']);\n   * const context = { user: { status: 'active' } };\n   * const result = inOp.compute(context); // true\n   * ```\n   */\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const resolvedValue = resolveValue(this.value);\n\n    if (!Array.isArray(this.list)) {\n      return false; // Or throw an error, depending on desired behavior\n    }\n\n    return this.list.includes(resolvedValue);\n  }\n\n  /**\n   * Converts the IN operator to its JSON representation.\n   *\n   * This method serializes the operator, its value, and the list to a JSON format\n   * that can be stored, transmitted, or reconstructed later.\n   *\n   * @returns A JSON object representing the IN operator\n   *\n   * @example\n   * ```typescript\n   * const inOp = new InOperator('user.role', ['admin', 'moderator']);\n   * const json = inOp.toJSON();\n   * // Result: { operator: \"in\", args: [\"user.role\", [\"admin\", \"moderator\"]] }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"in\",\n      args: [\n        typeof this.value === \"object\" &&\n        this.value !== null &&\n        \"toJSON\" in this.value\n          ? this.value.toJSON()\n          : this.value,\n        this.list,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\nexport function lt(\n  left: OperatorValue,\n  right: OperatorValue\n): OperatorInterace {\n  return new Lt(left, right);\n}\n\nexport class Lt implements OperatorInterace {\n  constructor(\n    private left: OperatorValue,\n    private right: OperatorValue\n  ) {}\n\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const leftResult = resolveValue(this.left);\n    const rightResult = resolveValue(this.right);\n\n    // Type guard for comparison - both operands must be numbers or strings\n    if (\n      (typeof leftResult === \"number\" || typeof leftResult === \"string\") &&\n      (typeof rightResult === \"number\" || typeof rightResult === \"string\")\n    ) {\n      return leftResult < rightResult;\n    }\n\n    return false;\n  }\n\n  toJSON(): RuleJson {\n    return {\n      operator: \"lt\",\n      args: [\n        typeof this.left === \"object\" &&\n        this.left !== null &&\n        \"toJSON\" in this.left\n          ? this.left.toJSON()\n          : this.left,\n        typeof this.right === \"object\" &&\n        this.right !== null &&\n        \"toJSON\" in this.right\n          ? this.right.toJSON()\n          : this.right,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\nexport function lte(\n  left: OperatorValue,\n  right: OperatorValue\n): OperatorInterace {\n  return new Lte(left, right);\n}\n\nexport class Lte implements OperatorInterace {\n  constructor(\n    private left: OperatorValue,\n    private right: OperatorValue\n  ) {}\n\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const leftResult = resolveValue(this.left);\n    const rightResult = resolveValue(this.right);\n\n    // Type guard for comparison - both operands must be numbers or strings\n    if (\n      (typeof leftResult === \"number\" || typeof leftResult === \"string\") &&\n      (typeof rightResult === \"number\" || typeof rightResult === \"string\")\n    ) {\n      return leftResult <= rightResult;\n    }\n\n    return false;\n  }\n\n  toJSON(): RuleJson {\n    return {\n      operator: \"lte\",\n      args: [\n        typeof this.left === \"object\" &&\n        this.left !== null &&\n        \"toJSON\" in this.left\n          ? this.left.toJSON()\n          : this.left,\n        typeof this.right === \"object\" &&\n        this.right !== null &&\n        \"toJSON\" in this.right\n          ? this.right.toJSON()\n          : this.right,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\nexport function ne(\n  left: OperatorValue,\n  right: OperatorValue\n): OperatorInterace {\n  return new Ne(left, right);\n}\n\nexport class Ne implements OperatorInterace {\n  constructor(\n    private left: OperatorValue,\n    private right: OperatorValue\n  ) {}\n\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const leftResult = resolveValue(this.left);\n    const rightResult = resolveValue(this.right);\n\n    return leftResult !== rightResult;\n  }\n\n  toJSON(): RuleJson {\n    return {\n      operator: \"ne\",\n      args: [\n        typeof this.left === \"object\" &&\n        this.left !== null &&\n        \"toJSON\" in this.left\n          ? this.left.toJSON()\n          : this.left,\n        typeof this.right === \"object\" &&\n        this.right !== null &&\n        \"toJSON\" in this.right\n          ? this.right.toJSON()\n          : this.right,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace } from \"./operator_interace.js\";\n\n/**\n * Creates a NONE operator that checks if no elements in an array match a condition.\n *\n * This function creates a rule that evaluates to true if NONE of the elements in the\n * specified array satisfy the provided condition. It's useful for ensuring that no\n * element in an array meets certain criteria (negative condition checking).\n *\n * @param arrayPath - Path to the array in the context (e.g., \"user.roles\")\n * @param condition - The condition to test against each array element\n * @returns A NONE operator instance\n *\n * @example Basic usage with object properties\n * ```typescript\n * const rule = none('user.roles', eq('name', 'banned'));\n * const context = {\n *   user: {\n *     roles: [\n *       { name: 'user', active: true },\n *       { name: 'admin', active: true }\n *     ]\n *   }\n * };\n * const result = engine.evaluate(rule, context); // true (no banned roles)\n * ```\n *\n * @example Ensuring no expired permissions\n * ```typescript\n * const rule = none('user.permissions', lt('expiresAt', Date.now()));\n * ```\n *\n * @example Checking for security violations\n * ```typescript\n * const rule = none('user.loginAttempts',\n *   and(\n *     eq('status', 'failed'),\n *     gt('timestamp', Date.now() - 300000) // Last 5 minutes\n *   )\n * );\n * ```\n */\nexport function none(\n  arrayPath: string,\n  condition: OperatorInterace\n): OperatorInterace {\n  return new None(arrayPath, condition);\n}\n\n/**\n * NONE operator that checks if no elements in an array match a condition.\n *\n * The None class implements array traversal with negative condition matching,\n * returning true only if NO elements in the target array satisfy the specified\n * condition. It uses short-circuit evaluation, returning false as soon as any\n * element matches the condition.\n *\n * @example\n * ```typescript\n * const noneOp = new None('user.violations', eq('severity', 'critical'));\n * const context = {\n *   user: {\n *     violations: [\n *       { severity: 'warning' },\n *       { severity: 'minor' },\n *       { severity: 'info' }\n *     ]\n *   }\n * };\n * const result = noneOp.compute(context); // true (no critical violations)\n * ```\n */\nexport class None implements OperatorInterace {\n  /**\n   * Creates a new NONE operator instance.\n   *\n   * @param arrayPath - Path to the array in the context\n   * @param condition - The condition to test against each array element\n   */\n  constructor(\n    private arrayPath: string,\n    private condition: OperatorInterace\n  ) {}\n\n  /**\n   * Evaluates the NONE operation on the specified array.\n   *\n   * This method resolves the array path, then tests each element against\n   * the provided condition. Returns false as soon as any element matches\n   * the condition (short-circuit evaluation).\n   *\n   * @param context - Context object containing the array to evaluate\n   * @returns True if NO elements match the condition, false if any element matches\n   *\n   * @example\n   * ```typescript\n   * const noneOp = new None('orders', eq('status', 'cancelled'));\n   * const context = {\n   *   orders: [\n   *     { status: 'completed' },\n   *     { status: 'processing' },\n   *     { status: 'shipped' }\n   *   ]\n   * };\n   * const result = noneOp.compute(context); // true (no cancelled orders)\n   * ```\n   */\n  compute(context?: object): boolean {\n    if (!context) {\n      return true; // No context means no array, so no elements match\n    }\n\n    const arrayValue = getValueFromPath(context, this.arrayPath);\n\n    // If path doesn't resolve to an array, return true (no elements to match)\n    if (!Array.isArray(arrayValue)) {\n      return true;\n    }\n\n    // Empty arrays return true (no elements to match condition)\n    if (arrayValue.length === 0) {\n      return true;\n    }\n\n    // Test each element against the condition\n    for (const element of arrayValue) {\n      // Evaluate condition with element as root context\n      try {\n        if (this.condition.compute(element)) {\n          return false; // Short-circuit: one element matched\n        }\n      } catch {}\n    }\n\n    return true; // No elements matched the condition\n  }\n\n  /**\n   * Converts the NONE operator to its JSON representation.\n   *\n   * This method serializes the operator, array path, and condition to a JSON format\n   * that can be stored, transmitted, or reconstructed later.\n   *\n   * @returns A JSON object representing the NONE operator\n   *\n   * @example\n   * ```typescript\n   * const noneOp = new None('user.flags', eq('type', 'security_risk'));\n   * const json = noneOp.toJSON();\n   * // Result: {\n   * //   operator: \"none\",\n   * //   args: [\n   * //     \"user.flags\",\n   * //     { operator: \"eq\", args: [\"type\", \"security_risk\"] }\n   * //   ]\n   * // }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"none\",\n      args: [this.arrayPath, this.condition.toJSON()],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\n/**\n * Creates a logical NOT operator that negates a condition.\n *\n * This function creates a rule that returns the opposite boolean value\n * of the provided operand. If the operand evaluates to true, NOT returns\n * false, and vice versa.\n *\n * @param operand - The operand to negate (can be a literal, context path, or nested operator)\n * @returns A NOT operator instance\n *\n * @example Negating a literal\n * ```typescript\n * const rule = not(false);\n * const result = engine.evaluate(rule); // true\n * ```\n *\n * @example Negating a comparison\n * ```typescript\n * const rule = not(eq('user.status', 'inactive'));\n * const context = { user: { status: 'active' } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example Complex negation\n * ```typescript\n * const rule = not(\n *   and(\n *     eq('user.role', 'guest'),\n *     eq('user.verified', false)\n *   )\n * );\n * ```\n */\nexport function not(operand: OperatorValue): OperatorInterace {\n  return new Not(operand);\n}\n\n/**\n * Logical NOT operator that negates a boolean condition.\n *\n * The Not class implements logical negation, returning the opposite\n * boolean value of its operand. It's useful for creating rules that\n * check for the absence of a condition or the opposite of a condition.\n *\n * @example\n * ```typescript\n * const notOp = new Not(eq('user.banned', true));\n * const context = { user: { banned: false } };\n * const result = notOp.compute(context); // true\n * ```\n */\nexport class Not implements OperatorInterace {\n  /**\n   * Creates a new NOT operator instance.\n   *\n   * @param operand - The operand to negate\n   */\n  constructor(private operand: OperatorValue) {}\n\n  /**\n   * Evaluates the NOT operation on the operand.\n   *\n   * This method resolves the operand (handling context paths and nested operators)\n   * and then returns the logical negation of the resolved value. It uses JavaScript's\n   * truthiness evaluation, so values like 0, false, null, undefined, and empty\n   * strings will be considered falsy.\n   *\n   * @param context - Optional context object for resolving path-based operands\n   * @returns True if the operand evaluates to false, false if it evaluates to true\n   *\n   * @example\n   * ```typescript\n   * const notOp = new Not(eq('user.verified', false));\n   * const context = { user: { verified: false } };\n   * const result = notOp.compute(context); // true (NOT false = true)\n   * ```\n   */\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const result = resolveValue(this.operand);\n    return !result;\n  }\n\n  /**\n   * Converts the NOT operator to its JSON representation.\n   *\n   * This method serializes the operator and its operand to a JSON format\n   * that can be stored, transmitted, or reconstructed later.\n   *\n   * @returns A JSON object representing the NOT operator\n   *\n   * @example\n   * ```typescript\n   * const notOp = new Not(eq('user.active', false));\n   * const json = notOp.toJSON();\n   * // Result: {\n   * //   operator: \"not\",\n   * //   args: [{ operator: \"eq\", args: [\"user.active\", false] }]\n   * // }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"not\",\n      args: [\n        typeof this.operand === \"object\" &&\n        this.operand !== null &&\n        \"toJSON\" in this.operand\n          ? this.operand.toJSON()\n          : this.operand,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\nexport function notIn(\n  value: OperatorValue,\n  list: Array<unknown>\n): OperatorInterace {\n  return new NotInOperator(value, list);\n}\n\nexport class NotInOperator implements OperatorInterace {\n  constructor(\n    private value: OperatorValue,\n    private list: Array<unknown>\n  ) {}\n\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    const resolvedValue = resolveValue(this.value);\n\n    if (!Array.isArray(this.list)) {\n      return true; // If it's not a list, the value is not 'in' it.\n    }\n\n    return !this.list.includes(resolvedValue);\n  }\n\n  toJSON(): RuleJson {\n    return {\n      operator: \"notIn\",\n      args: [\n        typeof this.value === \"object\" &&\n        this.value !== null &&\n        \"toJSON\" in this.value\n          ? this.value.toJSON()\n          : this.value,\n        this.list,\n      ],\n    };\n  }\n}\n","import type { RuleJson } from \"../serializer.js\";\nimport { getValueFromPath } from \"../utils.js\";\nimport type { OperatorInterace, OperatorValue } from \"./operator_interace.js\";\n\n/**\n * Creates a logical OR operator that evaluates multiple conditions.\n *\n * This function creates a rule that returns true when ANY of the\n * provided conditions evaluate to true. If all conditions are false,\n * the entire OR operation returns false.\n *\n * @param args - Variable number of operands (literals, context paths, or nested operators)\n * @returns An OR operator instance\n *\n * @example Basic OR operation\n * ```typescript\n * const rule = or(\n *   eq('user.role', 'admin'),\n *   eq('user.role', 'moderator')\n * );\n * const context = { user: { role: 'admin' } };\n * const result = engine.evaluate(rule, context); // true\n * ```\n *\n * @example Complex nested OR\n * ```typescript\n * const rule = or(\n *   and(\n *     eq('user.role', 'admin'),\n *     eq('user.active', true)\n *   ),\n *   and(\n *     eq('user.role', 'guest'),\n *     eq('user.verified', true)\n *   )\n * );\n * ```\n */\nexport function or(...args: Array<OperatorValue>): OperatorInterace {\n  return new Or(...args);\n}\n\n/**\n * Logical OR operator that evaluates multiple conditions.\n *\n * The Or class implements logical disjunction, requiring only ONE operand\n * to evaluate to true for the overall result to be true. It uses\n * short-circuit evaluation, stopping at the first true condition.\n *\n * @example\n * ```typescript\n * const orOp = new Or(\n *   eq('user.role', 'admin'),\n *   eq('user.role', 'moderator')\n * );\n * const context = { user: { role: 'moderator' } };\n * const result = orOp.compute(context); // true\n * ```\n */\nexport class Or implements OperatorInterace {\n  private args: Array<OperatorValue>;\n\n  /**\n   * Creates a new OR operator instance.\n   *\n   * @param args - Variable number of operands to evaluate with OR logic\n   */\n  constructor(...args: Array<OperatorValue>) {\n    this.args = args;\n  }\n\n  /**\n   * Evaluates the OR operation across all operands.\n   *\n   * This method uses short-circuit evaluation, returning true as soon as\n   * any operand evaluates to true. Only if ALL operands are falsy will\n   * the result be false. It handles context path resolution and nested operators.\n   *\n   * @param context - Optional context object for resolving path-based operands\n   * @returns True if ANY operand evaluates to true, false if all are false\n   *\n   * @example\n   * ```typescript\n   * const orOp = new Or(\n   *   eq('user.status', 'premium'),\n   *   eq('user.status', 'gold'),\n   *   eq('user.status', 'platinum')\n   * );\n   * const context = {\n   *   user: { status: 'gold' }\n   * };\n   * const result = orOp.compute(context); // true\n   * ```\n   */\n  compute(context?: object): boolean {\n    const resolveValue = (val: unknown) => {\n      if (typeof val === \"string\" && context) {\n        const resolved = getValueFromPath(context, val);\n        if (resolved !== undefined) {\n          return resolved;\n        }\n      }\n      return typeof val === \"object\" && val !== null && \"compute\" in val\n        ? (val as OperatorInterace).compute(context)\n        : val;\n    };\n\n    return this.args.some((arg) => {\n      return resolveValue(arg);\n    });\n  }\n\n  /**\n   * Converts the OR operator to its JSON representation.\n   *\n   * This method serializes the operator and all its operands to a JSON format,\n   * recursively handling nested operators while preserving the logical structure.\n   *\n   * @returns A JSON object representing the OR operator and its operands\n   *\n   * @example\n   * ```typescript\n   * const orOp = new Or(\n   *   eq('user.role', 'admin'),\n   *   eq('user.role', 'moderator')\n   * );\n   * const json = orOp.toJSON();\n   * // Result: {\n   * //   operator: \"or\",\n   * //   args: [\n   * //     { operator: \"eq\", args: [\"user.role\", \"admin\"] },\n   * //     { operator: \"eq\", args: [\"user.role\", \"moderator\"] }\n   * //   ]\n   * // }\n   * ```\n   */\n  toJSON(): RuleJson {\n    return {\n      operator: \"or\",\n      args: this.args.map((arg) => {\n        return typeof arg === \"object\" && arg !== null && \"toJSON\" in arg\n          ? arg.toJSON()\n          : arg;\n      }),\n    };\n  }\n}\n","import { All } from \"./operator/all.js\";\nimport { And } from \"./operator/and.js\";\nimport { Any } from \"./operator/any.js\";\nimport { Eq } from \"./operator/eq.js\";\nimport { Gt } from \"./operator/gt.js\";\nimport { Gte } from \"./operator/gte.js\";\nimport { InOperator } from \"./operator/in.js\";\nimport { Lt } from \"./operator/lt.js\";\nimport { Lte } from \"./operator/lte.js\";\nimport { Ne } from \"./operator/ne.js\";\nimport { None } from \"./operator/none.js\";\nimport { Not } from \"./operator/not.js\";\nimport { NotInOperator } from \"./operator/notIn.js\";\nimport type { OperatorInterace } from \"./operator/operator_interace.js\";\nimport { Or } from \"./operator/or.js\";\n\n/**\n * Represents the JSON structure of a serialized rule.\n *\n * This type defines the format used when converting rules to/from JSON,\n * enabling persistence and transmission of rule definitions.\n *\n * @example\n * ```typescript\n * const ruleJson: RuleJson = {\n *   operator: \"and\",\n *   args: [\n *     { operator: \"eq\", args: [\"user.age\", 25] },\n *     { operator: \"eq\", args: [\"user.status\", \"active\"] }\n *   ]\n * };\n * ```\n */\nexport type RuleJson = {\n  /** The name of the operator (e.g., \"eq\", \"and\", \"or\", \"gt\", etc.) */\n  operator: string;\n  /** Array of arguments for the operator, can include nested rules */\n  args: Array<unknown>;\n};\n\n/**\n * Maps operator names to their corresponding class constructors.\n *\n * This internal mapping is used by the deserializer to instantiate\n * the correct operator class based on the operator name in the JSON.\n */\nconst operatorMap: {\n  [key: string]: new (...args: any[]) => OperatorInterace;\n} = {\n  and: And,\n  eq: Eq,\n  or: Or,\n  not: Not,\n  ne: Ne,\n  gt: Gt,\n  gte: Gte,\n  lt: Lt,\n  lte: Lte,\n  in: InOperator,\n  notIn: NotInOperator,\n  any: Any,\n  all: All,\n  none: None,\n};\n\n/**\n * Handles serialization and deserialization of rules to/from JSON format.\n *\n * The RuleSerializer enables persistence and transmission of rule definitions\n * by converting between rule objects (OperatorInterface instances) and their\n * JSON representations. This is useful for storing rules in databases,\n * configuration files, or sending them over network APIs.\n *\n * @example Basic usage\n * ```typescript\n * import { RuleSerializer } from './serializer.js';\n * import { eq, and } from './operators.js';\n *\n * const serializer = new RuleSerializer();\n *\n * // Create a rule\n * const rule = and(\n *   eq('user.age', 25),\n *   eq('user.status', 'active')\n * );\n *\n * // Serialize to JSON\n * const jsonRule = serializer.serialize(rule);\n * console.log(JSON.stringify(jsonRule, null, 2));\n *\n * // Deserialize back to rule object\n * const deserializedRule = serializer.deserialize(jsonRule);\n * ```\n */\nexport class RuleSerializer {\n  /**\n   * Converts a rule object into its JSON representation.\n   *\n   * This method takes any rule that implements the OperatorInterface\n   * and converts it to a JSON object that can be stored, transmitted,\n   * or processed by other systems.\n   *\n   * @param rule - The rule to serialize (must implement OperatorInterface)\n   * @returns A JSON object representing the rule structure\n   *\n   * @example\n   * ```typescript\n   * const serializer = new RuleSerializer();\n   * const rule = eq('user.name', 'John');\n   * const json = serializer.serialize(rule);\n   * // Result: { operator: \"eq\", args: [\"user.name\", \"John\"] }\n   * ```\n   */\n  serialize(rule: OperatorInterace): RuleJson {\n    return rule.toJSON();\n  }\n\n  /**\n   * Converts a JSON representation back into a rule object.\n   *\n   * This method takes a JSON object (with the RuleJson structure)\n   * and reconstructs the corresponding rule object. It handles\n   * nested rules recursively, allowing for complex rule structures.\n   *\n   * @param jsonRule - The JSON representation of the rule\n   * @returns A rule object that implements OperatorInterface\n   * @throws Error if the operator type is unknown or unsupported\n   *\n   * @example\n   * ```typescript\n   * const serializer = new RuleSerializer();\n   * const jsonRule = {\n   *   operator: \"and\",\n   *   args: [\n   *     { operator: \"eq\", args: [\"user.age\", 25] },\n   *     { operator: \"gt\", args: [\"user.score\", 80] }\n   *   ]\n   * };\n   *\n   * const rule = serializer.deserialize(jsonRule);\n   * // Returns an And operator containing Eq and Gt operators\n   * ```\n   */\n  deserialize(jsonRule: RuleJson): OperatorInterace {\n    const OperatorClass = operatorMap[jsonRule.operator];\n    if (!OperatorClass) {\n      throw new Error(`Unknown operator: ${jsonRule.operator}`);\n    }\n\n    const resolvedArgs = jsonRule.args.map((arg) => {\n      if (typeof arg === \"object\" && arg !== null && \"operator\" in arg) {\n        // If the argument is another rule, deserialize it recursively\n        return this.deserialize(arg as RuleJson);\n      } else {\n        return arg;\n      }\n    });\n\n    // Create an instance of the operator class with the resolved arguments\n    return new OperatorClass(...resolvedArgs);\n  }\n}\n"],"mappings":"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","names":[]}